{"version":3,"file":"js/4834.f5e6434e.js","mappings":"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","sources":["webpack://my-project/./node_modules/@arcgis/core/node_modules/@esri/calcite-components/dist/components/nonChromiumPlatformUtils.js"],"sourcesContent":["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.0.0-beta.97\n */\nimport { e as rectToClientRect } from './floating-ui.js';\n\n/**\n * This module provides utils to fix positioning across shadow DOM in non-Chromium browsers\n *\n * It is based on floating-ui's distributable\n */\n/**\n * ðŸ‘‡ the following are needed to fix shadow DOM positioning ðŸ‘‡ï¸\n *\n * @param element\n */\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === \"fixed\") {\n    return null;\n  }\n  return composedOffsetParent(element);\n}\n/**\n * Polyfills the old offsetParent behavior from before the spec was changed:\n * https://github.com/w3c/csswg-drafts/issues/159\n *\n * @param element\n */\nfunction composedOffsetParent(element) {\n  let { offsetParent } = element;\n  let ancestor = element;\n  let foundInsideSlot = false;\n  while (ancestor && ancestor !== offsetParent) {\n    const { assignedSlot } = ancestor;\n    if (assignedSlot) {\n      let newOffsetParent = assignedSlot.offsetParent;\n      if (getComputedStyle(assignedSlot).display === \"contents\") {\n        const hadStyleAttribute = assignedSlot.hasAttribute(\"style\");\n        const oldDisplay = assignedSlot.style.display;\n        assignedSlot.style.display = getComputedStyle(ancestor).display;\n        newOffsetParent = assignedSlot.offsetParent;\n        assignedSlot.style.display = oldDisplay;\n        if (!hadStyleAttribute) {\n          assignedSlot.removeAttribute(\"style\");\n        }\n      }\n      ancestor = assignedSlot;\n      if (offsetParent !== newOffsetParent) {\n        offsetParent = newOffsetParent;\n        foundInsideSlot = true;\n      }\n    }\n    else if (isShadowRoot(ancestor) && ancestor.host && foundInsideSlot) {\n      break;\n    }\n    ancestor = (isShadowRoot(ancestor) && ancestor.host) || ancestor.parentNode;\n  }\n  return offsetParent;\n}\nfunction getElementRects(_ref) {\n  const { reference, floating, strategy } = _ref;\n  return {\n    reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n    floating: { ...getDimensions(floating), x: 0, y: 0 }\n  };\n}\n/**\n * â˜ï¸ the following are needed to fix shadow DOM positioning â˜ï¸\n */\n/**\n * ðŸ‘‡ the following are taken directly from floating-ui's ESM distributable to support the exports above ðŸ‘‡ï¸\n *\n * **Notes**:\n * unused functions are removed\n * ESLint is disabled\n * TS-warnings are suppressed\n */\n/* eslint-disable */\nfunction isWindow(value) {\n  return value && value.document && value.location && value.alert && value.setInterval;\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n  return node;\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeName(node) {\n  return isWindow(node) ? \"\" : node ? (node.nodeName || \"\").toLowerCase() : \"\";\n}\nfunction getUAString() {\n  // @ts-ignore\n  const uaData = navigator.userAgentData;\n  if (uaData != null && uaData.brands) {\n    return uaData.brands.map((item) => item.brand + \"/\" + item.version).join(\" \");\n  }\n  return navigator.userAgent;\n}\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === \"undefined\") {\n    return false;\n  }\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const { overflow, overflowX, overflowY, display } = getComputedStyle(element);\n  return (/auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX) && ![\"inline\", \"contents\"].includes(display));\n}\nfunction isTableElement(element) {\n  return [\"table\", \"td\", \"th\"].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle(element); // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return (css.transform !== \"none\" ||\n    css.perspective !== \"none\" ||\n    (isFirefox && css.willChange === \"filter\") ||\n    (isFirefox && (css.filter ? css.filter !== \"none\" : false)) ||\n    [\"transform\", \"perspective\"].some((value) => css.willChange.includes(value)) ||\n    [\"paint\", \"layout\", \"strict\", \"content\"].some(\n    // TS 4.1 compat\n    (value) => {\n      const contain = css.contain;\n      return contain != null ? contain.includes(value) : false;\n    }));\n}\nfunction isLayoutViewport() {\n  // Not Safari\n  return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways\n  // â€¢ Always-visible scrollbar or not\n  // â€¢ Width of <html>, etc.\n  // const vV = win.visualViewport;\n  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\nfunction isLastTraversableNode(node) {\n  return [\"html\", \"body\", \"#document\"].includes(getNodeName(node));\n}\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n  const win = isElement(element) ? getWindow(element) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  const x = (clientRect.left +\n    (addVisualOffsets\n      ? (_win$visualViewport$o =\n        (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null\n        ? _win$visualViewport$o\n        : 0\n      : 0)) /\n    scaleX;\n  const y = (clientRect.top +\n    (addVisualOffsets\n      ? (_win$visualViewport$o2 =\n        (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null\n        ? _win$visualViewport$o2\n        : 0\n      : 0)) /\n    scaleY;\n  const width = clientRect.width / scaleX;\n  const height = clientRect.height / scaleY;\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // @ts-ignore\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\nfunction isScaled(element) {\n  // @ts-ignore\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, // @ts-ignore - checked above (TS 4.1 compat)\n  isOffsetParentAnElement && isScaled(offsetParent), strategy === \"fixed\");\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || (!isOffsetParentAnElement && strategy !== \"fixed\")) {\n    if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      // @ts-ignore\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n    else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === \"html\") {\n    return node;\n  }\n  return (\n  // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n  // @ts-ignore\n  node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || // DOM Element detected\n    (isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n  );\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    }\n    else {\n      const parent = currentNode.parentNode;\n      currentNode = isShadowRoot(parent) ? parent.host : parent;\n    }\n  }\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === \"static\") {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n  if (offsetParent &&\n    (getNodeName(offsetParent) === \"html\" ||\n      (getNodeName(offsetParent) === \"body\" &&\n        getComputedStyle(offsetParent).position === \"static\" &&\n        !isContainingBlock(offsetParent)))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\nfunction getDimensions(element) {\n  if (isHTMLElement(element)) {\n    return {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  }\n  // @ts-ignore\n  const rect = getBoundingClientRect(element);\n  return {\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n    if (layoutViewport || (!layoutViewport && strategy === \"fixed\")) {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body || html).direction === \"rtl\") {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n  if (list === void 0) {\n    list = [];\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  const target = isBody\n    ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [])\n    : scrollableAncestor;\n  const updatedList = list.concat(target);\n  return isBody\n    ? updatedList // @ts-ignore: isBody tells us target will be an HTMLElement here\n    : updatedList.concat(getOverflowAncestors(target));\n}\nfunction contains(parent, child) {\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n    do {\n      // use `===` replace node.isSameNode()\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore: need a better way to handle this...\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n  return false;\n}\nfunction getNearestParentCapableOfEscapingClipping(element, clippingAncestors) {\n  let currentNode = element;\n  while (currentNode && !isLastTraversableNode(currentNode) && !clippingAncestors.includes(currentNode)) {\n    if (isElement(currentNode) && [\"absolute\", \"fixed\"].includes(getComputedStyle(currentNode).position)) {\n      break;\n    }\n    const parentNode = getParentNode(currentNode);\n    currentNode = isShadowRoot(parentNode) ? parentNode.host : parentNode;\n  }\n  return currentNode;\n}\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, false, strategy === \"fixed\");\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingParent, strategy) {\n  if (clippingParent === \"viewport\") {\n    return rectToClientRect(getViewportRect(element, strategy));\n  }\n  if (isElement(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent, strategy);\n  }\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping ancestor\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\nfunction getClippingAncestors(element) {\n  // @ts-ignore\n  const clippingAncestors = getOverflowAncestors(element);\n  const nearestEscapableParent = getNearestParentCapableOfEscapingClipping(element, clippingAncestors);\n  let clipperElement = null;\n  if (nearestEscapableParent && isHTMLElement(nearestEscapableParent)) {\n    const offsetParent = getOffsetParent(nearestEscapableParent);\n    if (isOverflowElement(nearestEscapableParent)) {\n      clipperElement = nearestEscapableParent;\n    }\n    else if (isHTMLElement(offsetParent)) {\n      clipperElement = offsetParent;\n    }\n  }\n  if (!isElement(clipperElement)) {\n    return [];\n  } // @ts-ignore isElement check ensures we return Array<Element>\n  return clippingAncestors.filter((clippingAncestors) => clipperElement &&\n    isElement(clippingAncestors) &&\n    contains(clippingAncestors, clipperElement) &&\n    getNodeName(clippingAncestors) !== \"body\");\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\nfunction getClippingRect(_ref) {\n  let { element, boundary, rootBoundary, strategy } = _ref;\n  const mainClippingAncestors = boundary === \"clippingAncestors\" ? getClippingAncestors(element) : [].concat(boundary);\n  const clippingAncestors = [...mainClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nexport { getClippingRect, getElementRects, getOffsetParent };\n"],"names":["getTrueOffsetParent","element","isHTMLElement","getComputedStyle","position","composedOffsetParent","offsetParent","ancestor","foundInsideSlot","assignedSlot","newOffsetParent","display","hadStyleAttribute","hasAttribute","oldDisplay","style","removeAttribute","isShadowRoot","host","parentNode","getElementRects","_ref","reference","floating","strategy","getRectRelativeToOffsetParent","getOffsetParent","getDimensions","x","y","isWindow","value","document","location","alert","setInterval","getWindow","node","window","ownerDocument","defaultView","getNodeName","nodeName","toLowerCase","getUAString","uaData","navigator","userAgentData","brands","map","item","brand","version","join","userAgent","HTMLElement","isElement","Element","isNode","Node","ShadowRoot","OwnElement","isOverflowElement","overflow","overflowX","overflowY","test","includes","isTableElement","isContainingBlock","isFirefox","css","transform","perspective","willChange","filter","some","contain","isLayoutViewport","isLastTraversableNode","min","Math","max","round","getBoundingClientRect","includeScale","isFixedStrategy","_win$visualViewport$o","_win$visualViewport","_win$visualViewport$o2","_win$visualViewport2","clientRect","scaleX","scaleY","offsetWidth","width","offsetHeight","height","win","addVisualOffsets","left","visualViewport","offsetLeft","top","offsetTop","right","bottom","getDocumentElement","documentElement","getNodeScroll","scrollLeft","scrollTop","pageXOffset","pageYOffset","getWindowScrollBarX","isScaled","rect","isOffsetParentAnElement","scroll","offsets","offsetRect","clientLeft","clientTop","getParentNode","getContainingBlock","currentNode","parent","getViewportRect","html","clientWidth","clientHeight","layoutViewport","getDocumentRect","_element$ownerDocumen","body","scrollWidth","scrollHeight","direction","getNearestOverflowAncestor","getOverflowAncestors","list","_node$ownerDocument","scrollableAncestor","isBody","target","concat","updatedList","contains","child","rootNode","getRootNode","next","getNearestParentCapableOfEscapingClipping","clippingAncestors","getInnerBoundingClientRect","getClientRectFromClippingAncestor","clippingParent","getClippingAncestors","nearestEscapableParent","clipperElement","getClippingRect","boundary","rootBoundary","mainClippingAncestors","firstClippingAncestor","clippingRect","reduce","accRect","clippingAncestor"],"sourceRoot":""}